<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2012 (1.2)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Network Models</TITLE>
<META NAME="description" CONTENT="Network Models">
<META NAME="keywords" CONTENT="manual">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2012">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="manual.css">

<LINK REL="next" HREF="node7.html">
<LINK REL="previous" HREF="node5.html">
<LINK REL="up" HREF="manual.html">
<LINK REL="next" HREF="node7.html">
</HEAD>

<BODY >
<!--Navigation Panel-->
<A NAME="tex2html171"
  HREF="node7.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html167"
  HREF="manual.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html161"
  HREF="node5.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html169"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html172"
  HREF="node7.html">Variable Structure Models</A>
<B> Up:</B> <A NAME="tex2html168"
  HREF="manual.html">A Discrete EVent system</A>
<B> Previous:</B> <A NAME="tex2html162"
  HREF="node5.html">Atomic Models</A>
 &nbsp; <B>  <A NAME="tex2html170"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL>
<LI><A NAME="tex2html173"
  HREF="node6.html#SECTION00610000000000000000">Parts of a Network Model</A>
<UL>
<LI><A NAME="tex2html174"
  HREF="node6.html#SECTION00611000000000000000">The <B><I>route</I></B> method</A>
<LI><A NAME="tex2html175"
  HREF="node6.html#SECTION00612000000000000000">The <B><I>getComponents</I></B> method</A>
<LI><A NAME="tex2html176"
  HREF="node6.html#SECTION00613000000000000000">Illegal networks</A>
</UL>
<BR>
<LI><A NAME="tex2html177"
  HREF="node6.html#SECTION00620000000000000000">Simulating a Network Model</A>
<LI><A NAME="tex2html178"
  HREF="node6.html#SECTION00630000000000000000">A complete example of a network model</A>
<LI><A NAME="tex2html179"
  HREF="node6.html#SECTION00640000000000000000">Digraph Models</A>
<LI><A NAME="tex2html180"
  HREF="node6.html#SECTION00650000000000000000">Cell Space Models</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION00600000000000000000"></A>
<A NAME="chapter:network_models"></A>
<BR>
Network Models
</H1>
A network model comprises atomic models and other network models that are interconnected. Network models can be components of other network models, thereby enabling the construction of multi-level systems. Unlike atomic models, network models do not directly define new dynamic behavior. The dynamics of a network model are determined by the dynamics of its component parts and their interactions. Atomic models define fundamental behaviors; network models define structure. 

<P>

<H1><A NAME="SECTION00610000000000000000"></A>
<A NAME="section:parts_of_a_network_model"></A>
<BR>
Parts of a Network Model
</H1>
Network models are derived from the <B>Network</B> class. This class has two virtual methods: <B><I>route</I></B> and <B><I>getComponents</I></B>. The <B><I>route</I></B> method implements connections between the components of the network and between these components and the inputs and outputs of the network itself. The <B><I>getComponents</I></B> method provides the set of components that constitute the network.

<P>

<H2><A NAME="SECTION00611000000000000000">
The <B><I>route</I></B> method</A>
</H2>
The <B><I>route</I></B> method realizes three types of connections. The first are connections between components of the network. The second are connections from the network's inputs to the inputs of its component models. The third are connections from the component outputs to the outputs of the network. The signature of the <B><I>route</I></B> method is
<PRE>
void route(const X&amp; value, Devs&lt;X&gt;* model, Bag&lt;Event&lt;X&gt; &gt;&amp; r)
</PRE>

<P>
The value argument is the object to route, the model argument is the <B>Network</B> or <B>Atomic</B> model that is the source of the value object, and the r argument is a bag to be filled with models that should receive the value object as input. Each target is described by an <B>Event</B> object that carries two pieces of information: a pointer to the model that is the target and the object to be delivered to that target. The simulator uses the <B>Event</B> objects in one of three ways depending on the relationship between the source of the object and its target. These uses are

<OL>
<LI>If the source is a component of the network and the target is the network itself, then the value becomes an output from the network.
</LI>
<LI>If the source is the network and the target is a component of the network, then the value becomes an input to that component.
</LI>
<LI>If the source and target are both components of the network, then the value becomes an input to the target.
</LI>
</OL>
Any other relationship between the source and the target is illegal and causes the simulator to raise an exception.

<P>

<DIV ALIGN="CENTER"><A NAME="fig:atomic_to_atomic_coupling"></A><A NAME="988"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 5.1:</STRONG>
Two connected <B>Atomic</B> components in a single <B>Network</B>.</CAPTION>
<TR><TD><IMG
 WIDTH="318" HEIGHT="146" BORDER="0"
 SRC="img8.png"
 ALT="\begin{figure}\centering
\epsfig{file=network_models_figs/connected_atomic_models.eps}\end{figure}"></TD></TR>
</TABLE>
</DIV>
The simplest example of the <B><I>route</I></B> method converts output from one <B>Atomic</B> component into input for another <B>Atomic</B> component. Figure <A HREF="#fig:atomic_to_atomic_coupling">5.1</A> illustrates this case. The simulator begins by invoking the <B><I>output_func</I></B> method of <B>Atomic</B> model <IMG
 WIDTH="16" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$ A$">
. Next, the simulator iterates through the elements of <IMG
 WIDTH="16" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$ A$">
's output bag, calling the <B>Network</B>'s <B><I>route</I></B> method for each one. The arguments passed to <B><I>route</I></B> at each call are

<OL>
<LI>the output object itself, which is the value argument,
</LI>
<LI>a pointer to <IMG
 WIDTH="16" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$ A$">
, which is the model argument, and
</LI>
<LI>an empty <B>Bag</B> for holding <B>Event</B> objects.
</LI>
</OL> 

<P>
Two things are done by the <B><I>route</I></B> method to cause <B>Atomic</B> model <IMG
 WIDTH="17" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img9.png"
 ALT="$ B$">
 to receive the output object from <IMG
 WIDTH="16" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$ A$">
. First, an <B>Event</B> object is created that contains the output object and a pointer to <IMG
 WIDTH="17" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img9.png"
 ALT="$ B$">
. Second, this <B>Event</B> object is inserted into the <B>Bag</B> r. If we suppose, for the sake of illustration, that input and output objects have type int, then the <B><I>route</I></B> method for this example is
<PRE>
void route(const int&amp; value, Devs&lt;int&gt;* model, Bag&lt;Event&lt;int&gt; &gt;&amp; r) {
   if (model == A) {
      Event&lt;int&gt; e(B,value);
      r.insert(e);
   }
}
</PRE>
where <IMG
 WIDTH="16" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$ A$">
 and <IMG
 WIDTH="17" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img9.png"
 ALT="$ B$">
 are pointers to the respective models. This route method implements the network shown in Fig. <A HREF="#fig:atomic_to_atomic_coupling">5.1</A>.

<P>
A more complicated example is the network receiving input destined for one of its atomic components. This can happen, for instance, when the network is a component of another network. Suppose the input to the network is to become input for <B>Atomic</B> model <IMG
 WIDTH="16" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$ A$">
. Figure <A HREF="#fig:eic_atomic_to_atomic_coupling">5.2</A> extends Fig. <A HREF="#fig:atomic_to_atomic_coupling">5.1</A> to include this connection.

<DIV ALIGN="CENTER"><A NAME="fig:eic_atomic_to_atomic_coupling"></A><A NAME="989"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 5.2:</STRONG>
Two connected <B>Atomic</B> components with external input coupling to component <IMG
 WIDTH="16" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$ A$">
.</CAPTION>
<TR><TD><IMG
 WIDTH="337" HEIGHT="146" BORDER="0"
 SRC="img10.png"
 ALT="\begin{figure}\centering
\epsfig{file=network_models_figs/eic_atomic_atomic_coupling.eps}\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>
When an event appears at the input of the network, the simulator calls the <B>Network</B>'s <B><I>route</I></B> method with the following arguments:

<OL>
<LI>the input object, which is the value argument,
</LI>
<LI>a pointer to the <B>Network</B> that is receiving the input, and
</LI>
<LI>an empty <B>Bag</B> for holding <B>Event</B> objects.
</LI>
</OL> 
As before, <B><I>route</I></B> creates an <B>Event</B> object that indicates the target model and value of the input. This <B>Event</B> object is put into the <B>Bag</B> r of receivers. The code below implements the network shown in Fig. <A HREF="#fig:eic_atomic_to_atomic_coupling">5.2</A>; note that `this' points to the <B>Network</B> itself (i.e., to the network that is receiving the initial input).
<PRE>
void route(const int&amp; value, Devs&lt;int&gt;* model, Bag&lt;Event&lt;int&gt; &gt;&amp; r) {
   if (model == A) {
       Event&lt;int&gt; e(B,value);
       r.insert(e);
   }
   else if (model == this) {
       Event&lt;int&gt; e(A,value);
       r.insert(e);
   }
}
</PRE>

<P>

<DIV ALIGN="CENTER"><A NAME="fig:big_coupling"></A><A NAME="725"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 5.3:</STRONG>
A network with external input, external output, and internal coupling.</CAPTION>
<TR><TD><IMG
 WIDTH="369" HEIGHT="146" BORDER="0"
 SRC="img11.png"
 ALT="\begin{figure}\centering
\epsfig{file=network_models_figs/big_coupled.eps}\end{figure}"></TD></TR>
</TABLE>
</DIV>
For a complete example, the network is extended to include two more connections: a connection from the output of model <IMG
 WIDTH="17" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img9.png"
 ALT="$ B$">
 to the output of the network and a feedback connection from <IMG
 WIDTH="17" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img9.png"
 ALT="$ B$">
 to <IMG
 WIDTH="16" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$ A$">
. This configuration is shown in Fig. <A HREF="#fig:big_coupling">5.3</A>. These new connections require an additional case in the route method. This case checks for output from <IMG
 WIDTH="17" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img9.png"
 ALT="$ B$">
 and, if such an output is found, directs it to both <IMG
 WIDTH="16" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$ A$">
 and the network. An <B>Event</B> object is created for each target and added to the <B>Bag</B> r of receivers: one of these <B>Event</B>s results in an input to <IMG
 WIDTH="16" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$ A$">
 and the other in an output from the network. Here is the implementation.
<PRE>
void route(const int&amp; value, Devs&lt;int&gt;* model, Bag&lt;Event&lt;int&gt; &gt;&amp; r) {
   if (model == A) {
        Event&lt;int&gt; e(B,value);
        r.insert(e);
    }
    else if (model == this) {
        Event&lt;int&gt; e(A,value);
        r.insert(e);
    }
    else if (model == B) {
        Event&lt;int&gt; e1(this,value);
        Event&lt;int&gt; e2(A,value);
        r.insert(e1);
        r.insert(e2);
    }
}
</PRE>

<P>
Though not demonstrated above, the <B><I>route</I></B> method is allowed to modify the value object before sending it to a target. This can be useful in some instances.

<P>

<H2><A NAME="SECTION00612000000000000000">
The <B><I>getComponents</I></B> method</A>
</H2>
The <B><I>getComponents</I></B> method is the other virtual method that must be implemented by any class that is derived from <B>Network</B>. The simulator passes to this method an empty <B>Set</B> of pointers to models, and this set must be filled with the network's components. The signature of the getComponents method is
<PRE>
void getComponents(Set&lt;Devs&lt;X&gt;*&gt;&amp; c)
</PRE>
where c is the set to be filled. The code below shows how this method is implemented for the two component network shown in Fig. <A HREF="#fig:big_coupling">5.3</A>. This code, of course, also works for the networks shown in Figs. <A HREF="#fig:eic_atomic_to_atomic_coupling">5.2</A> and <A HREF="#fig:atomic_to_atomic_coupling">5.1</A>.
<PRE>
void getComponents(Set&lt;Devs&lt;int&gt;*&gt;&amp; c) { 
   c.insert(A);
   c.insert(B);
}
</PRE>

<P>

<H2><A NAME="SECTION00613000000000000000">
Illegal networks</A>
</H2>
There are two rules that must be followed when building networks. First, components cannot be connected to themselves. This means that direct feedback loops and connections directly through a network model are illegal. The former can always be replaced with an internal event and the latter by simply bypassing the network. These two cases are illustrated in Fig. <A HREF="#fig:bad_coupling">5.4</A>. Second, direct coupling can only occur between components belonging to the same network, and every component must belong to at most one network. 

<DIV ALIGN="CENTER"><A NAME="fig:bad_coupling"></A><A NAME="991"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 5.4:</STRONG>
Illegal coupling in a <B>Network</B> model.</CAPTION>
<TR><TD><IMG
 WIDTH="316" HEIGHT="174" BORDER="0"
 SRC="img12.png"
 ALT="\begin{figure}\centering
\epsfig{file=network_models_figs/bad_couplings.eps}\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>

<H1><A NAME="SECTION00620000000000000000">
Simulating a Network Model</A>
</H1>
There are four steps in each iteration of the simulation algorithm. These are

<OL>
<LI>Advance the simulation clock to the time of the next event.
</LI>
<LI>Compute the outputs from atomic models that will change state (i.e., that will undergo an internal or confluent event) and convert these outputs into inputs for other models.
</LI>
<LI>Calculate the next state of each model with events - internal, external, or both to process.
</LI>
<LI>Cleanup garbage left over from the output calculations.
</LI>
</OL>
These four steps are repeated until the time of the next event is at infinity (i.e., DBL_MAX) or you decide to stop the simulation. 

<P>
There are no special rules for simulating hierarchical models. The simulator considers the entire collection of atomic models when determining the next event time, output from atomic models are recursively routed to their atomic destinations, and the state transitions and garbage collection are performed over the complete set of active atomic components. Hierarchies of network models are a convenient organizing tool for the modeler, but the simulator flattens (indirectly, via its recursive routing of events) multi-level networks during simulation.

<P>
Algorithm <A HREF="#alg:coupled_model">1</A> sketches the simulation procedure. Note that the procedure for simulating atomic models (see section <A HREF="node5.html#section:atomic_models">4</A>) is embedded in the procedure for simulating network models. The rules for atomic models do not change: each atomic model sees a sequence of input events and produces a sequence of output events just as before. The only difference here is that the input events are created by other atomic models, and so the input sequence for each atomic model is constructed as the simulation progresses.
<BR>
<A NAME="alg:coupled_model"></A><IMG
 WIDTH="556" HEIGHT="540" ALIGN="BOTTOM" BORDER="0"
 SRC="img13.png"
 ALT="\begin{algorithm}
% latex2html id marker 758\begin{algorithmic}
\STATE Initial...
...orithmic}\caption{The simulation procedure for a network model.}
\end{algorithm}">
<BR>

<P>

<H1><A NAME="SECTION00630000000000000000">
A complete example of a network model</A>
</H1>
I'll use the <B>SimpleDigraph</B> class to illustrate how to build a network model. The <B>SimpleDigraph</B> models a network of components whose connections are represented with a directed graph. If, for example, component <IMG
 WIDTH="16" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$ A$">
 is connected to component <IMG
 WIDTH="17" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img9.png"
 ALT="$ B$">
, then all output from <IMG
 WIDTH="16" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$ A$">
 becomes input to <IMG
 WIDTH="17" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img9.png"
 ALT="$ B$">
.

<P>
The <B>SimpleDigraph</B> has two methods for building a network. The <B><I>add</I></B> method takes an <B>Atomic</B> or <B>Network</B> model and adds it to the set of components. The <B><I>couple</I></B> method accepts a pair of components and connects the first to the second. Below is the class definition for the model. Note that it has a template parameter for setting its input and output type.  
<PRE>
template &lt;class VALUE&gt; class SimpleDigraph: public Network&lt;VALUE&gt; { 
   public:
      /// A component of the SimpleDigraph model
      typedef Devs&lt;VALUE&gt; Component;

      /// Construct a network with no components
      SimpleDigraph():Network&lt;VALUE&gt;(){}
      /// Add a model to the network.
      void add(Component* model);
      /// Couple the source model to the destination model  
      void couple(Component* src, Component* dst);
      /// Assigns the model component set to c
      void getComponents(Set&lt;Component*&gt;&amp; c);
      /// Use the coupling information to route an event
      void route(const VALUE&amp; x, Component* model, Bag&lt;Event&lt;VALUE&gt; &gt;&amp; r);
      /// The destructor destroys all of the component models
      ~SimpleDigraph();

   private:   
      // Component model set
      Set&lt;Component*&gt; models;
      // Coupling information
      std::map&lt;Component*,Bag&lt;Component*&gt; &gt; graph;
};
</PRE>
The <B>SimpleDigraph</B> has two member variables. The first is a set of pointers to the components of the network. These are stored in the <B>Set</B> called models. The components can be <B>Atomic</B> objects, <B>Network</B> objects, or both. These components of the <B>SimpleDigraph</B> are the nodes of its directed graph. The second member variable is the network's links. These are stored in the <B>map</B> called graph.

<P>
The <B>SimpleDigraph</B> has four methods plus the required <B><I>route</I></B> and <B><I>getComponents</I></B>. One of these is the constructor, which creates an empty network. Another is the destructor, which deletes all of the network's components. The remaining two are <B><I>add</I></B> and <B><I>couple</I></B>.

<P>
The <B><I>add</I></B> method does three things. First, it checks that the network is not being added to itself. This is illegal and will cause the simulator to throw an exception. Next, it adds the new component to its set of components. Last, the <B>SimpleDigraph</B> makes itself the component's parent. This needed so that the simulator can climb up and down the model tree. If this step is omitted then the recursive routing of events will fail. Here is the implementation of the <B><I>add</I></B> method.
<PRE>
template &lt;class VALUE&gt; 
void SimpleDigraph&lt;VALUE&gt;::add(Component* model) {
   assert(model != this);
   models.insert(model);
   model-&gt;setParent(this);
}
</PRE>

<P>
The <B><I>couple</I></B> method does two things. First, it adds the source (src) and destination (dst) models to the set of components. We could simply have required that the user call the <B><I>add</I></B> method before calling the <B><I>couple</I></B> method, but adding the components here doesn't hurt and might prevent an error. Second, <B><I>couple</I></B> adds the src <!-- MATH
 $\rightarrow$
 -->
<IMG
 WIDTH="20" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img14.png"
 ALT="$ \rightarrow$">
 dst link to the graph. Notice that the <B><I>SimpleDigraph</I></B> itself is a node in the network, but it is not in the set of components!. Components that are connected to the network cause outputs from the network. Similarly, connecting the network to a component causes input to the network to become input to the component. Here is the implementation of the <B><I>couple</I></B> method.
<PRE>
template &lt;class VALUE&gt;
void SimpleDigraph&lt;VALUE&gt;::couple(Component* src, Component* dst) { 
   if (src != this) add(src);
   if (dst != this) add(dst);
   graph[src].insert(dst);
}
</PRE>

<P>
Of the two required methods, <B><I>route</I></B> is the more complicated. The arguments to <B><I>route</I></B> are an object to be routed, the network element (i.e., either the <B>SimpleDigraph</B> or one of its components) that created that object, and the <B>Bag</B> to be filled with <B>Event</B> objects that indicate the object's receivers. The method begins by finding the collection of components that are connected to the source of the object. Next, it iterates through this collection and for each receiver adds an <B>Event</B> to the <B>Bag</B> of receivers. When this is done the method returns. The implementation is below.
<PRE>
template &lt;class VALUE&gt;
void SimpleDigraph&lt;VALUE&gt;::route(const VALUE&amp; x, Component* model,Bag&lt;Event&lt;VALUE&gt; &gt;&amp; r) {
   // Find the list of target models and ports
   typename std::map&lt;Component*,Bag&lt;Component*&gt; &gt;::iterator graph_iter;
   graph_iter = graph.find(model);
   // If no target, just return
   if (graph_iter == graph.end()) return;
   // Otherwise, add the targets to the event bag
   Event&lt;VALUE&gt; event;
   typename Bag&lt;Component*&gt;::iterator node_iter;
   for (node_iter = (*graph_iter).second.begin();
      node_iter != (*graph_iter).second.end(); node_iter++) {
      event.model = *node_iter;
      event.value = x;
      r.insert(event);
   }
}
</PRE>

<P>
The second required method, <B><I>getComponents</I></B>, is trivial. If we had used some collection other than a <B>Set</B> to store the components, then the method would have needed to explicitly insert every component model into the <B>Set</B> c. But because models and c are both <B>Set</B> objects, and the <B>Set</B> has an assignment operator, a call to that operator is sufficient.
<PRE>
template &lt;class VALUE&gt;
void SimpleDigraph&lt;VALUE&gt;::getComponents(Set&lt;Component*&gt;&amp; c) {
   c = models;
}
</PRE>

<P>
The constructor and the destructor complete the class. The constructor only calls the superclass constructor. The destructor deletes the component models. Its implementation is shown below.
<PRE>
template &lt;class VALUE&gt;
SimpleDigraph&lt;VALUE&gt;::~SimpleDigraph() {
   typename Set&lt;Component*&gt;::iterator i;
   for (i = models.begin(); i != models.end(); i++) {
      delete *i;
   }
}
</PRE>

<P>

<H1><A NAME="SECTION00640000000000000000"></A>
<A NAME="section:digraph_models"></A>
<BR>
Digraph Models
</H1>
This section introduces the <B>Digraph</B> model, which is part of the Adevs simulation library. The <B>Digraph</B> is a tool for building networks described by a block diagram. The model of the convenience store, developed in section <A HREF="node4.html#chapter:intro">3</A>, was our first example of a <B>Digraph</B> model. The code used to construct the convenience store model (without the <B>Observer</B>) is shown below. The block diagram that corresponds to this code snippet is shown in Fig. <A HREF="#fig:two_component_diagram">5.5</A>.
<PRE>
// Create a digraph model whose components use PortValue&lt;Customer*&gt;
// objects as input and output objects.
adevs::Digraph&lt;Customer*&gt; store;
// Create and add the component models
Clerk* clrk = new Clerk();
Generator* genr = new Generator(argv[1]);
store.add(clrk);
store.add(genr);
// Couple the components
store.couple(genr,genr-&gt;arrive,clrk,clrk-&gt;arrive);
</PRE>

<DIV ALIGN="CENTER"><A NAME="fig:two_component_diagram"></A><A NAME="995"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 5.5:</STRONG>
A <B>Digraph</B> model with two components.</CAPTION>
<TR><TD><IMG
 WIDTH="435" HEIGHT="95" BORDER="0"
 SRC="img15.png"
 ALT="\begin{figure}\centering
\epsfig{file=network_models_figs/two_component_model.eps}\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>
The components of a <B>Digraph</B> must use <B>adevs::PortValue</B> objects for their input and output type. The <B>Digraph</B> is a template class with two template parameters. The first parameter is the type of object used for a value in its <B>PortValue</B> objects. The second parameter is the type of object used for a port in its <B>PortValue</B> objects. The port parameter is of type `int' by default.

<P>
The <B>Digraph</B> has two methods that are used to construct a network. The <B><I>add</I></B> method adds a component to the network. The argument to the add method is the model to be included in the network. The <B><I>couple</I></B> method connects components of the network. The first two arguments to the <B><I>couple</I></B> method are the source model and port. The second two arguments are the destination model and port.

<P>
The effect of coupling a source model to a destination model is that output produced by the source model on the source port appears as input to the destination model on the destination port. To illustrate this, consider the output function of the <B>Generator</B> model shown in Fig. <A HREF="#fig:two_component_diagram">5.5</A>.
<PRE>
void Generator::output_func(Bag&lt;IO_Type&gt;&amp; yb)
{
    // First customer in the list is produced as output
    IO_Type output(arrive,arrivals.front());
    yb.insert(output);
}
</PRE>

<P>
This output function places a value of type `Customer*' on the ``arrive'' port of the <B>Generator</B>; recall that 'IO_Type' is a typedef for `PortValue&lt;Customer*&gt;'. A corresponding <B>PortValue</B> object appears in the input bag of the <B>Clerk</B>. The value attribute of the <B>PortValue</B> object received by the clerk points to the <B>Customer</B> object created by the <B>Generator</B>. The port attribute of the <B>PortValue</B> object is the <B>Clerk</B>'s ``arrive" port.

<P>
The components for the network need not consist only of <B>Atomic</B> models; the <B>Digraph</B> can also have other <B>Network</B> models as its components. For instance, suppose we want to model a convenience store that has two clerks. When customers are ready to pay their bill, they enter the shortest line. To build this model, we reuse the <B>Clerk</B>, <B>Generator</B> and <B>Observer</B> models introduced in section <A HREF="node4.html#chapter:intro">3</A>. We add a model called <B>Decision</B> of how customers select a line.

<P>
The code for the <B>Decision</B> model is shown below. This model has two output ports, one for each line, and there are three input ports. One input port accepts new customers. The others are used to track the number of customers departing each line: a customer departing either clerk generates an event on the appropriate input port. In this way, the model is able to track the number of customers in each line and assign new customers to the shortest one. Here is the class definition
<PRE>
#include "adevs.h"
#include "Customer.h"
#include &lt;list&gt;

// Number of lines to consider.
#define NUM_LINES 2

class Decision: public adevs::Atomic&lt;IO_Type&gt;
{
    public:
        /// Constructor.
        Decision();
        /// Internal transition function.
        void delta_int();
        /// External transition function.
        void delta_ext(double e, const adevs::Bag&lt;IO_Type&gt;&amp; x);
        /// Confluent transition function.
        void delta_conf(const adevs::Bag&lt;IO_Type&gt;&amp; x);
        /// Output function.  
        void output_func(adevs::Bag&lt;IO_Type&gt;&amp; y);
        /// Time advance function.
        double ta();
        /// Output value garbage collection.
        void gc_output(adevs::Bag&lt;IO_Type&gt;&amp; g);
        /// Destructor.
        ~Decision();
        /// Input port that receives new customers
        static const int decide;
        /// Input ports that receive customers leaving the two lines
        static const int departures[NUM_LINES];
        /// Output ports that produce customers for the two lines
        static const int arrive[NUM_LINES];

    private:
        /// Lengths of the two lines
        int line_length[NUM_LINES];
        /// List of deciding customers and their decision.
        std::list&lt;std::pair&lt;int,Customer*&gt; &gt; deciding;
        /// Delete all waiting customers and clear the list.
        void clear_deciders();
        /// Returns the arrive port associated with the shortest line
        int find_shortest_line();
};
</PRE>
and here is the implementation
<PRE>
#include "Decision.h"
#include &lt;iostream&gt;
using namespace std;
using namespace adevs;

// Assign identifiers to ports.  Assumes NUM_LINES = 2.
// The numbers are selected to allow indexing into the
// line length and port number arrays.
const int Decision::departures[NUM_LINES] = { 0, 1 };
const int Decision::arrive[NUM_LINES] = { 0, 1 };
// Inport port for arriving customer that need to make a decision
const int Decision::decide = NUM_LINES;

Decision::Decision():
Atomic&lt;IO_Type&gt;()
{
    // Set the initial line lengths to zero
    for (int i = 0; i &lt; NUM_LINES; i++)
    {
        line_length[i] = 0;
    }
}

void Decision::delta_int()
{
    // Move out all of the deciders
    deciding.clear();
}

void Decision::delta_ext(double e, const Bag&lt;IO_Type&gt;&amp; x)
{
    // Assign new arrivals to a line and update the line length
    Bag&lt;IO_Type&gt;::const_iterator iter = x.begin();
    for (; iter != x.end(); iter++)
    {
        if ((*iter).port == decide)
        {
            int line_choice = find_shortest_line();
            Customer* customer = new Customer(*((*iter).value));
            pair&lt;int,Customer*&gt; p(line_choice,customer);
            deciding.push_back(p);
            line_length[p.first]++;
        }
    }
    // Decrement the length of lines that had customers leave
    for (int i = 0; i &lt; NUM_LINES; i++)
    {
        iter = x.begin();
        for (; iter != x.end(); iter++)
        {
            if ((*iter).port &lt; NUM_LINES)
            {
                line_length[(*iter).port]--;
            }
        }
    }
}

void Decision::delta_conf(const Bag&lt;IO_Type&gt;&amp; x)
{
    delta_int();
    delta_ext(0.0,x);
}

double Decision::ta()
{
    // If there are customers getting into line, then produce output
    // immediately.
    if (!deciding.empty())
    {
        return 0.0;
    }
    // Otherwise, wait for another customer
    else
    {
        return DBL_MAX;
    }
}
        
void Decision::output_func(Bag&lt;IO_Type&gt;&amp; y)
{
    // Send all customers to their lines
    list&lt;pair&lt;int,Customer*&gt; &gt;::iterator i = deciding.begin();
    for (; i != deciding.end(); i++)
    {
        IO_Type event((*i).first,(*i).second);
        y.insert(event);
    }
}

void Decision::gc_output(Bag&lt;IO_Type&gt;&amp; g)
{
    Bag&lt;IO_Type&gt;::iterator iter = g.begin();
    for (; iter != g.end(); iter++)
    {
        delete (*iter).value;
    }
}

Decision::~Decision()
{
    clear_deciders();
}

void Decision::clear_deciders()
{
    list&lt;pair&lt;int,Customer*&gt; &gt;::iterator i = deciding.begin();
    for (; i != deciding.end(); i++)
    {
        delete (*i).second;
    }
    deciding.clear();
}

int Decision::find_shortest_line()
{
    int shortest = 0;
    for (int i = 0; i &lt; NUM_LINES; i++)
    {
        if (line_length[shortest] &gt; line_length[i])
        {
            shortest = i;
        }
    }
    return shortest;
}
</PRE>

<P>
The block diagram of the store and its multiple clerks is shown in Fig. <A HREF="#fig:multi_clerk_diagram">5.6</A>. The external interface for this block diagram is identical to that of the clerks. It has the same inputs and outputs as the <B>Clerk</B> and <B>Clerk2</B> models, and we can therefore use the <B>Generator</B> and <B>Observer</B> models to conduct the same experiments as before.

<P>
The external ``arrive" input of the multi-clerk model is connected to the ``decide" input of the <B>Decision</B> model. The ``depart" output ports of each of the <B>Clerk</B> models is connected to the external ``arrive" output port of the multi-clerk model. The <B>Decision</B> model has two output ports, each producing customers for a distinct clerk. These output ports are coupled to the ``arrive" port of the appropriate clerk. The <B>Clerk</B>'s ``depart" output ports are coupled to the appropriate ``departures" port of the decision model.

<DIV ALIGN="CENTER"><A NAME="fig:multi_clerk_diagram"></A><A NAME="896"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 5.6:</STRONG>
Component models and their interconnections in the multi-clerk convenience store model.</CAPTION>
<TR><TD><IMG
 WIDTH="492" HEIGHT="179" BORDER="0"
 SRC="img16.png"
 ALT="\begin{figure}\centering
\epsfig{file=network_models_figs/multi_clerk_diagram.eps}\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>
The multi-clerk model is implemented by deriving a new class from <B>Digraph</B>. The constructor of this new class creates and adds the component models and establishes their interconnections. Here is the header file for this new multi-clerk model.
<PRE>
#include "adevs.h"
#include "Clerk.h"
#include "Decision.h"

/**
A model of a store with multiple clerks and a "shortest line"
decision process for customers.
*/
class MultiClerk: public adevs::Digraph&lt;Customer*&gt;
{
    public:
        // Model input port
        static const int arrive;
        // Model output port
        static const int depart;
        // Constructor.
        MultiClerk();
        // Destructor.
        ~MultiClerk();
};
</PRE>
And here is the source file
<PRE>
#include "MultiClerk.h"
using namespace std;
using namespace adevs;

// Assign identifiers to I/O ports
const int MultiClerk::arrive = 0;
const int MultiClerk::depart = 1;

MultiClerk::MultiClerk():
Digraph&lt;Customer*&gt;()
{
    // Create and add component models
    Decision* d = new Decision();
    add(d);
    Clerk* c[NUM_LINES];
    for (int i = 0; i &lt; NUM_LINES; i++)
    {
        c[i] = new Clerk();
        add(c[i]);
    }
    // Create model connections
    couple(this,this-&gt;arrive,d,d-&gt;decide);
    for (int i = 0; i &lt; NUM_LINES; i++)
    {
        couple(d,d-&gt;arrive[i],c[i],c[i]-&gt;arrive);
        couple(c[i],c[i]-&gt;depart,d,d-&gt;departures[i]);
        couple(c[i],c[i]-&gt;depart,this,this-&gt;depart);
    }
}

MultiClerk::~MultiClerk()
{
}
</PRE>
Notice that the <B>MultiClerk</B> destructor does not delete its component models. This is because the components are adopted by the base class when they are added using the <B>Digraph</B>'s <B><I>add</I></B> method. Consequently, the component models are deleted by the base class destructor, rather than the destructor of the derived class.

<P>

<H1><A NAME="SECTION00650000000000000000">
Cell Space Models</A>
</H1>
A cell space model is a collection of atomic and network models arrange in a regular grid and with each model connected to its neighboring models. Conway's Game of Life is a classic example of a cell space model that can be described very nicely as a discrete event system. This game is played on a flat board divided into regular cells much like a checkerboard. Each cell has a neighborhood that comprises its eight adjacent cells: above, below, left, right, and the four corners. A cell can be dead or alive. The switch from dead to alive and vice versa occurs according to two rules:

<OL>
<LI>(Death rule). If a cell is alive and it has less than two or more than three living neighbors then the cell dies.
</LI>
<LI>(Rebirth rule). If a cell is dead and it has three three living neighbors then the cell is reborn.
</LI>
</OL>

<P>
Our implementation of the Game of Life has two parts: atomic models that implement the individual cells and a <B>CellSpace</B> that contains the cells. The <B>CellSpace</B> is a type of <B>Network</B>, and its components exchange <B>CellEvent</B> objects that have four attributes: the x, y, and z coordinates of the target cell (the cell space can have three dimensions; the Game of Life uses just two) and the object to deliver to that target. The <B>CellEvent</B> class is a template class whose template argument sets the type of object that the event delivers. The size of the <B>CellSpace</B> is determined when the <B>CellSpace</B> object is created, and it has methods for adding and retrieving cells by location. 

<P>
The <B>Atomic</B> cells in our Game of Life have two state variables: the dead or alive status of the cell and its count of living neighbors. Two methods are implemented to test the death and rebirth rules, and the cell sets its time advance to 1 whenever a rule is satisfied.

<P>
The output of the cell is its new dead or alive state. In order to produce properly targeted <B>CellEvent</B>s, each cell knows its own location in the cell space. The internal transition function causes the cell to change its dead/alive state. The external transition function updates the cell's count of living neighbors as those neighbors change their dead/alive state. Here is header file for our Game of Life cell.
<PRE>
/// Possible cell phases
typedef enum { Dead, Alive } Phase;
/// IO type for a cell
typedef adevs::CellEvent&lt;Phase&gt; CellEvent;

/// A cell in the Game of Life.  
class Cell: public adevs::Atomic&lt;CellEvent&gt; {
   public:
      /**
      Create a cell and set the initial state.
      The width and height fields are used to determine if a
      cell is an edge cell.  The last phase pointer is used to
      visualize the cell space.
      */
      Cell(long int x, long int y, long int width, long int height, 
      Phase phase, short int nalive, Phase* vis_phase = NULL);

      ... Required Adevs methods and destructor ...

   private:   
      // location of the cell in the 2D space
      long int x, y;
      // dimensions of the 2D space
      static long int w, h;
      // Current cell phase
      Phase phase;
      // number of living neighbors.
      short int nalive;
      // Output variable for visualization
      Phase* vis_phase;

      // Returns true if the cell will be born
      bool check_born_rule() const {
         return (phase == Dead &amp;&amp; nalive == 3);
      }
      // Return true if the cell will die
      bool check_death_rule() const {
         return (phase == Alive &amp;&amp; (nalive &lt; 2 || nalive &gt; 3));
      }
};
</PRE>

<P>
The template argument supplied to the base <B>Atomic</B> class is a <B>CellEvent</B> whose value attribute has the type <B>Phase</B>. The <B><I>check_born_rule</I></B> method tests the rebirth condition and the <B><I>check_death_rule</I></B> method tests the death condition. The appropriate rule, as determined by the cell's dead or alive status, is used in the time advance, output, and internal transition methods (i.e., if the cell is dead then check the rebirth rule; if alive, check the death rule). The number of living cells is updated by the cell's <B><I>delta_ext</I></B> method when neighboring cells report a change in their state. Here are the <B>Cell</B>'s method implementations.
<PRE>
Cell::Cell(long int x, long int y, long int w, long int h, 
Phase phase, short int nalive, Phase* vis_phase):
adevs::Atomic&lt;CellEvent&gt;(),x(x),y(y),phase(phase),nalive(nalive),vis_phase(vis_phase) {
   // Set the global cellspace dimensions
   Cell::w = w; Cell::h = h;
   // Set the initial visualization value
   if (vis_phase != NULL) *vis_phase = phase;
}

double Cell::ta() {
   // If a phase change should occur then change state 
   if (check_death_rule() || check_born_rule()) return 1.0;
   // Otherwise, do nothing
   return DBL_MAX;
}

void Cell::delta_int() { 
   // Change the cell state if necessary
   if (check_death_rule()) phase = Dead;
   else if (check_born_rule()) phase = Alive;
}

void Cell::delta_ext(double e, const adevs::Bag&lt;CellEvent&gt;&amp; xb) {
   // Update the living neighbor count 
   adevs::Bag&lt;CellEvent&gt;::const_iterator iter;
   for (iter = xb.begin(); iter != xb.end(); iter++) {
      if ((*iter).value == Dead) nalive--;
      else nalive++;
   }
}

void Cell::delta_conf(const adevs::Bag&lt;CellEvent&gt;&amp; xb) { 
   delta_int();
   delta_ext(0.0,xb);
}

void Cell::output_func(adevs::Bag&lt;CellEvent&gt;&amp; yb) { 
   CellEvent e;
   // Assume we are dying
   e.value = Dead;
   // Check in case this in not true
   if (check_born_rule()) e.value = Alive;
   // Set the visualization value
   if (vis_phase != NULL) *vis_phase = e.value;
   // Generate an event for each neighbor
   for (long int dx = -1; dx &lt;= 1; dx++) {
      for (long int dy = -1; dy &lt;= 1; dy++) {
         e.x = (x+dx)%w;
         e.y = (y+dy)%h;
         if (e.x &lt; 0) e.x = w-1;
         if (e.y &lt; 0) e.y = h-1;
         // Don't send to self
         if (e.x != x || e.y != y)
            yb.insert(e);
      }
   }
}
</PRE>

<P>
The <B><I>output_func</I></B> method shows how a cell sends messages to its neighbors. The nested for loops create a <B>CellEvent</B> targeted at each adjacent cell. The location of the targeted cell is written to the x, y, and z attributes of the <B>CellEvent</B> object. Just like arrays, the locations range from zero to the cell space's size minus one. The <B>CellSpace</B> routes the <B>CellEvent</B> objects to their targets. However, if the target of the <B>CellEvent</B> is outside of the cell space, then the <B>CellSpace</B> itself will produce the <B>CellEvent</B> as an output.

<P>
The remainder of the simulation program looks very much like the simulation programs that we've seen. A <B>CellSpace</B> object is created and we add cells to it. Then a <B>Simulator</B> object is created and a pointer to the <B>CellSpace</B> is passed to the <B>Simulator</B>'s constructor. Last, we execute events until our stopping criteria is met. The execution part is already familiar, so let's just focus on creating the <B>CellSpace</B>. Here is the code snippet that performs the construction.
<PRE>
// Create the cellspace model
cell_space = new adevs::CellSpace&lt;Phase&gt;(WIDTH,HEIGHT);
for (int x = 0; x &lt; WIDTH; x++) {
   for (int y = 0; y &lt; HEIGHT; y++) {
       // Count the living neighbors
       short int nalive = count_living_cells(x,y);
       // The 2D phase array contains the initial Dead/Alive state of each cell
       cell_space-&gt;add(new Cell(x,y,WIDTH,HEIGHT,phase[x][y],nalive,&amp;(phase[x][y])),x,y);
   }
}
</PRE>

<P>
Just as with the <B>Digraph</B> class, the <B>CellSpace</B> template argument determines the value type for the <B>CellEvent</B> objects used as input and output. The <B>CellSpace</B> constructor sets the dimensions of the space. Every <B>CellSpace</B> is three dimensional, and the constructor accepts three arguments for its x, y, and z dimensions. Omitted arguments default to 1. The signature of the constructor is
<PRE>
CellSpace(long int width, long int height = 1, long int depth = 1)
</PRE>

<P>
Components are added to the cellspace with the <B><I>add</I></B> method. This method places a component at a specific x, y, and z location. Its signature is
<PRE>
void add(Cell* model, long int x, long int y = 0, long int z = 0)
</PRE>
where <B>Cell</B> is a <B>Devs</B> (atomic or network) by the type definition
<PRE>
typedef Devs&lt;CellEvent&lt;X&gt; &gt; Cell;
</PRE>
Also like the <B>Digraph</B>, the <B>CellSpace</B> deletes its components when it is deleted.

<P>
The <B>CellSpace</B> has five methods for retrieving cells and the dimensions of the cell space. These are more or less self-explanatory; the signatures are shown below.
<PRE>
const Cell* getModel(long int x, long int y = 0, long int z = 0) const;
Cell* getModel(long int x, long int y = 0, long int z = 0);
long int getWidth() const;
long int getHeight() const;
long int getDepth() const;
</PRE>

<P>
The Game of Life produces a surprising number of distinct patterns. Some of these patterns are fixed and unchanging. Others oscillate, cycling through a set of patterns that always repeats itself. Still others seem to crawl or fly. One common pattern is the Block, which is shown in Fig. <A HREF="#fig:gol_block">5.7</A>. Our discrete event implementation of the Game of Life doesn't do any work when simulating a Block. None of the cells in a Block change in any way: their states are constant and so are their neighbor counts.

<DIV ALIGN="CENTER"><A NAME="fig:gol_block"></A><A NAME="967"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure 5.7:</STRONG>
The Block.</CAPTION>
<TR><TD><IMG
 WIDTH="138" HEIGHT="138" BORDER="0"
 SRC="img17.png"
 ALT="\begin{figure}\centering
\epsfig{file=network_models_figs/block_pattern.eps}\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>

<DIV ALIGN="CENTER"><A NAME="fig:gol_blinker"></A><A NAME="996"></A>
<TABLE>
<CAPTION ALIGN="BOTTOM"><STRONG>Figure:</STRONG>
The Blinker. The input, output, and state transitions for the cell marked with a * are shown in Table <A HREF="#tab:blinker_cell_activity">5.1</A>. The address of each cell is shown in its upper left corner. Living cells are indicated with a $.</CAPTION>
<TR><TD><IMG
 WIDTH="389" HEIGHT="201" BORDER="0"
 SRC="img18.png"
 ALT="\begin{figure}\centering
\epsfig{file=network_models_figs/blinker.eps}\end{figure}"></TD></TR>
</TABLE>
</DIV>
The Blinker in Fig. <A HREF="#fig:gol_blinker">5.8</A> is more interesting. This oscillating pattern has just two stages: a vertical and a horizontal. Table <A HREF="#tab:blinker_cell_activity">5.1</A> shows the input, output, and state transitions that are computed for the cell marked with a * in Fig. <A HREF="#fig:gol_blinker">5.8</A>. Just like the pattern it is a part of, the cells oscillates between two different states.
<BR><P></P>
<DIV ALIGN="CENTER"><A NAME="997"></A>
<TABLE>
<CAPTION><STRONG>Table 5.1:</STRONG>
State, input, and output trajectory for the cell marked with * in Fig. <A HREF="#fig:gol_blinker">5.8</A>.</CAPTION>
<TR><TD>
<DIV ALIGN="CENTER"><TABLE CELLPADDING=3 BORDER="1">
<TR><TD ALIGN="LEFT">Time</TD>
<TD ALIGN="LEFT">State</TD>
<TD ALIGN="LEFT">Input</TD>
<TD ALIGN="LEFT">Output to all neighbors</TD>
</TR>
<TR><TD ALIGN="LEFT">0</TD>
<TD ALIGN="LEFT">(dead,3)</TD>
<TD ALIGN="LEFT">No input</TD>
<TD ALIGN="LEFT">No Output</TD>
</TR>
<TR><TD ALIGN="LEFT">1</TD>
<TD ALIGN="LEFT">(alive,1)</TD>
<TD ALIGN="LEFT">(dead,2,1,0)  (dead,2,3,0)</TD>
<TD ALIGN="LEFT">alive</TD>
</TR>
<TR><TD ALIGN="LEFT">2</TD>
<TD ALIGN="LEFT">(dead,1)</TD>
<TD ALIGN="LEFT">(alive,2,1,0)  (alive,2,3,0)</TD>
<TD ALIGN="LEFT">dead</TD>
</TR>
</TABLE>

<A NAME="tab:blinker_cell_activity"></A></DIV></TD></TR>
</TABLE>
</DIV><P></P>
<BR>

<P>
The confluent transition function plays an important role in the Blinker. All but the first row in Table <A HREF="#tab:blinker_cell_activity">5.1</A> has simultaneous input and output, which means that an internal and external event coincide. Consequently, the next state of the cell is determined by its <B><I>delta_conf</I></B> method. It is also important that the input and output bags carry multiple values. The external transition function (which is used in defining the confluent transition function) must be able to compute the number of living neighbors before determining its next state. If input events were provided one at a time (e.g., if the input bag were replaced by a single input event), then our discrete event Game of Life would be much more difficult to implement.
	<HR>
<!--Navigation Panel-->
<A NAME="tex2html171"
  HREF="node7.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next.png"></A> 
<A NAME="tex2html167"
  HREF="manual.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up.png"></A> 
<A NAME="tex2html161"
  HREF="node5.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="prev.png"></A> 
<A NAME="tex2html169"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A NAME="tex2html172"
  HREF="node7.html">Variable Structure Models</A>
<B> Up:</B> <A NAME="tex2html168"
  HREF="manual.html">A Discrete EVent system</A>
<B> Previous:</B> <A NAME="tex2html162"
  HREF="node5.html">Atomic Models</A>
 &nbsp; <B>  <A NAME="tex2html170"
  HREF="node1.html">Contents</A></B> 
<!--End of Navigation Panel-->
<ADDRESS>
rotten
2014-02-19
</ADDRESS>
</BODY>
</HTML>
